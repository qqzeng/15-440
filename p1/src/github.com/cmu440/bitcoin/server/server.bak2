package main

import (
	"container/list"
	"fmt"
	"github.com/cmu440/bitcoin"
	"github.com/cmu440/lsp"
	"log"
	"os"
	"strconv"
    "sync"
    "sync/atomic"
)

const (
	name = "log.txt"
	flag = os.O_RDWR | os.O_CREATE
	perm = os.FileMode(0666)

	// default global params
	defaultEpochLimit  = 5
	defaultEpochMillis = 1000
	defaultWindowSize  = 3
)

// client reqeust struct
type cliRequest struct {
	connID int
	mesg   *bitcoin.Message
}

type JobStatus int

const (
	Completed JobStatus = iota
    Running
	Abort
)

type job struct {
	jobId  int
	mesg   *bitcoin.Message
	status JobStatus
}

type minerRequest struct {
	connID     int
	mesg       *bitcoin.Message
	jobs       map[int]*job
}

type serverNode struct {
    mu                sync.Mutex
	srv               lsp.Server
	chanExit          chan bool
    chanCliRequest    chan cliRequest
	// chanMinnerRequest chan minerRequest
    minerRequestMap  map[int]*minerRequest // minner join request map
	params            *lsp.Params
	logger            *log.Logger
}

func main() {
	const numArgs = 2
	if len(os.Args) != numArgs {
		fmt.Println("Usage: ./server <port>")
		return
	}

	// TODO: implement this!
	port, err := strconv.Atoi(os.Args[1])
	if err != nil {
		fmt.Println("Port error!")
		return
	}
	sn := createServerNode(port)
	sn.logger.Printf("serverNode create successfully!.\n")

}

func (sn *serverNode) sendRequest(jobId int) {
    sn.mu.Lock()
    defer sn.mu.Unlock()
    for e := sn.minerRequestList.Front(); e != nil; e = e.Next() {
        mr, _ := e.Value.(*minerRequest)
        server.Write(mr.connID, mr.jobs[jobId])
    }
}

func (sn *serverNode) distributeRequests() {
    for {
        select {
        case cliReq := <-sn.chanCliRequest:
            sn.mu.Lock()
            start := cliReq.mesg.Lower
            // assign the request to all live minners.
            avg := (cliReq.mesg.Upper - cliReq.mesg.Lower) / len(sn.minerRequestList)
            jobId = getNextJobId()
            for e := sn.minerRequestList.Front(); e != nil; e = e.Next() {
                // sub-message reqeust handled by per miner
                msg := bitcoin.NewRequest(bitcoin.Request, cliReq.mesg.data, start, start + avg)
                // job info for every sub-message matained for miner
                job := &job{
                    jobId: jobId,
                    mesg: msg,
                    status: Running,
                }
                mr, _ := e.Value.(*minerRequest)
                mr.jobs[jobId] = job
                start = start + avg + 1
            }
            sn.mu.Unlock()
            sn.sendRequest(jobId)
        }
    }
}

func (sn *serverNode) updateMinerMesg(connID int, data *bitcoin.Message) {
    sn.mu.Lock()
    defer sn.mu.Unlock()
    // sn.minerRequestMap[connID].jobs
}

func (sn *serverNode) cacheMinerMesg(connID int, data *bitcoin.Message) {
    // wait for goroutine read the minerRequestList.
    sn.mu.Lock()
    minerReq := &minerRequest{
        connID: connID,
        mesg:   data,
        jobs:  make(map[int]job), // initial empty job map.
    }
    sn.logger.Printf("Server cached Join message %s from minner %d.\n", string(data), connID)
    sn.minerRequestMap[connID] = minerReq
    sn.mu.Unlock()
}

func (sn. *serverNode) cacheCliMesg(connID int, data *bitcoin.Message) {
	// wait for goroutine read the cliRequestList.
	cliReq := &cliRequest{
		connID: connID,
		mesg:   data,
	}
    sn.chanCliRequest <- cliReq
	sn.logger.Printf("Server cached Client message %s from client %d.\n", string(data), connID)
}

func (sn *serverNode) handleMesg() {
	defer sn.logger.Println("Server shutting down...")
	for {
		select {
		case <-sn.chanExit:
			return
		default:
			connID, data, err := sn.srv.Read()
			if err != nil {
				sn.logger.Println("Server received error during read.")
				return
			}
			sn.logger.Printf("Server read message %s from client %d.\n", string(data), connID)
			mesg, err := data.(*Message)
			switch mesg.Type {
			case bitcoin.Join:
				go sn.cacheMinerMesg(connID, data)
            case bitcoin.Request:
                go sn.cacheCliMesg(connID, data)
            case bitcoin.Result:
                go sn.updateMinerMesg(connID, data)
            default:
                sn.logger.Println("Invalid message type!")
			}
		}
	}
}

func createServerNode(port int) *serverNode {
	sn := &serverNode {
        minerRequestMap: make(map[int]minerRequest),
        chanCliRequest: make(chan bool, 1),
        chanMinnerRequest: make(chan bool, 1),
    }
	logger, err := buildLogger()
	if err != nil {
		fmt.Println("Logger build error: ", err)
		return nil
	}
	sn.logger = logger
	sn.params = makeParams()
	srv, err := lsp.NewServer(port, sn.params)
	if err != nil {
		sn.logger.Printf("Failed to start server on port %d: %s\n", port, err)
		return nil
	}
	sn.srv = srv
	return sn
}

func buildLogger() (*log.Logger, error) {
	file, err := os.OpenFile(name, flag, perm)
	if err != nil {
		return nil, err
	}
	LOGF := log.New(file, "", log.Lshortfile|log.Lmicroseconds)
	return LOGF, nil
}

func makeParams() *lsp.Params {
	return &lsp.Params{
		EpochLimit:  defaultEpochLimit,
		EpochMillis: defaultEpochMillis,
		WindowSize:  defaultWindowSize,
	}
}

var nextJobId int32 = 0
func getNextJobId() {
    return int(atomic.AddInt32(&nextJobId, 1))
}